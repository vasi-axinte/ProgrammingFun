using System;

namespace Theory
{
    class Program
    {
        static void Main(string[] args)
        {
            //Inheritance.InheritanceTheory ui = new Inheritance.InheritanceTheory();
            //Queue.QueueThoery ui = new Queue.QueueThoery();
            //Stack.StackTheory ui = new Stack.StackTheory();
            //ClassesAndObjects.ClassesAndObjectsTheory ui = new ClassesAndObjects.ClassesAndObjectsTheory();
            //Interfaces.InterfacesTheory ui = new Interfaces.InterfacesTheory();
            //Constructor.ConstructorTheory ui = new Constructor.ConstructorTheory();
            //Destructor.DestructorTheory ui = new Destructor.DestructorTheory();
            //OOPPrinciples.Abstraction.AbstractionTheory ui = new OOPPrinciples.Abstraction.AbstractionTheory();  
            //OOPPrinciples.Encapsulation.EncapsulationTheory ui = new OOPPrinciples.Encapsulation.EncapsulationTheory();
            //OOPPrinciples.Polymorphism.PolymorphismTheory ui = new OOPPrinciples.Polymorphism.PolymorphismTheory();
            //OOPPrinciples.Inheritance.InheritanceThoery ui = new OOPPrinciples.Inheritance.InheritanceThoery();
            //AbstractClassesVSInterfaces.AbstractClassesTheory ui = new AbstractClassesVSInterfaces.AbstractClassesTheory();
            //AbstractClassesVSInterfaces.InterfacesTheory ui = new AbstractClassesVSInterfaces.InterfacesTheory();
            //AbstractClassesVSInterfaces.InterfacesTheory ui = new AbstractClassesVSInterfaces.InterfacesTheory();
            //SOLIDPrinciples.SingleResponsabilityPrinciple.SingleResponsabilityTheory ui = new SOLID_Principles.SingleResponsability_Principle.SingleResponsabilityTheory();
            //SOLIDPrinciples.InterfaceSegregationPrinciple.InterfaceSegregationPrincipleTheory ui = new SOLIDPrinciples.InterfaceSegregationPrinciple.InterfaceSegregationPrincipleTheory();
            //SOLIDPrinciples.OpenClosedPrinciple.OpenClosedPrincipleTheory ui = new SOLIDPrinciples.OpenClosedPrinciple.OpenClosedPrincipleTheory();
            //SOLIDPrinciples.LiskovSubstitutionPrinciple.LiskovSubstitutionTheory ui = new SOLIDPrinciples.LiskovSubstitutionPrinciple.LiskovSubstitutionTheory();
            //SOLIDPrinciples.DependencyInversionPrinciple.DependencyInversionTheory ui = new SOLIDPrinciples.DependencyInversionPrinciple.DependencyInversionTheory();
            //DRYPrinciple.DRYPrincipleTheory ui = new DRYPrinciple.DRYPrincipleTheory();
            //DesignPatterns.AbstractFactory.AbstractFactoryTheory ui = new DesignPatterns.AbstractFactory.AbstractFactoryTheory();
            //DesignPatterns.FactoryMethod.FactoryMethodThoery ui = new DesignPatterns.FactoryMethod.FactoryMethodThoery();
            //DesignPatterns.Singleton.SingletonTheory ui = new DesignPatterns.Singleton.SingletonTheory();
            //BuilderDesignPattern.BuilderTheory ui = new BuilderDesignPattern.BuilderTheory();
            //ThreadsWithLock.ThreadsTheory ui = new ThreadsWithLock.ThreadsTheory();
            //ThreadsWithoutLock.ThreadsTheory ui = new ThreadsWithoutLock.ThreadsTheory();
            //RegexTheory.RegexTheory ui = new RegexTheory.RegexTheory();
            //ThreadsDeadlock.DeadlockTheory ui = new ThreadsDeadlock.DeadlockTheory();
            //SealedClass.SealedTheory ui = new SealedClass.SealedTheory();
            //TaskAndThreads.TaskTheory ui = new TaskAndThreads.TaskTheory();
            //Threadpool.ThreadpoolTheory ui = new Threadpool.ThreadpoolTheory();
            //RecursiveFunction.RecursiveTheory ui = new RecursiveFunction.RecursiveTheory();
            //ExceptionHandling.ExceptionHandlingTheory ui = new ExceptionHandling.ExceptionHandlingTheory();
            //ListAndDictionary.ListTheory ui = new ListAndDictionary.ListTheory();
            ListAndDictionary.DictionaryTheory ui = new ListAndDictionary.DictionaryTheory();
            ui.Execute();

        }
    }
}
