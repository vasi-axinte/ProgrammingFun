using System;

namespace Theory
{
    class Program
    {
        static void Main(string[] args)
        {
            //Inheritance.InheritanceTheory ui = new Inheritance.InheritanceTheory();
            //Queue.QueueThoery ui = new Queue.QueueThoery();
            //Stack.StackTheory ui = new Stack.StackTheory();
            //ClassesAndObjects.ClassesAndObjectsTheory ui = new ClassesAndObjects.ClassesAndObjectsTheory();
            //Interfaces.InterfacesTheory ui = new Interfaces.InterfacesTheory();
            //Constructor.ConstructorTheory ui = new Constructor.ConstructorTheory();
            //Destructor.DestructorTheory ui = new Destructor.DestructorTheory();
            //OOPPrinciples.Abstraction.AbstractionTheory ui = new OOPPrinciples.Abstraction.AbstractionTheory();  
            //OOPPrinciples.Encapsulation.EncapsulationTheory ui = new OOPPrinciples.Encapsulation.EncapsulationTheory();
            //OOPPrinciples.Polymorphism.PolymorphismTheory ui = new OOPPrinciples.Polymorphism.PolymorphismTheory();
            //OOPPrinciples.Inheritance.InheritanceThoery ui = new OOPPrinciples.Inheritance.InheritanceThoery();
            //Abstract_Classes_VS_Interfaces.AbstractClassesTheory ui = new Abstract_Classes_VS_Interfaces.AbstractClassesTheory();
            //Abstract_Classes_VS_Interfaces.InterfacesTheory ui = new Abstract_Classes_VS_Interfaces.InterfacesTheory();
            //Abstract_Classes_VS_Interfaces.InterfacesTheory ui = new Abstract_Classes_VS_Interfaces.InterfacesTheory();
            //SOLID_Principles.Single_Responsability_Principle.SingleResponsabilityTheory ui = new SOLID_Principles.Single_Responsability_Principle.SingleResponsabilityTheory();
            //SOLID_Principles.Interface_Segregation_Principle.Interface_Segregation_Principle_Theory ui = new SOLID_Principles.Interface_Segregation_Principle.Interface_Segregation_Principle_Theory();
            //SOLID_Principles.Open_Closed_Principle.OpenClosedPrincipleTheory ui = new SOLID_Principles.Open_Closed_Principle.OpenClosedPrincipleTheory();
            // SOLID_Principles.Liskov_Substitution_Principle.LiskovSubstitutionTheory ui = new SOLID_Principles.Liskov_Substitution_Principle.LiskovSubstitutionTheory();
            //SOLID_Principles.Dependency_Inversion_Principle.DependencyInversionTheory ui = new SOLID_Principles.Dependency_Inversion_Principle.DependencyInversionTheory();
            //DRY_Principle.DRYPrincipleTheory ui = new DRY_Principle.DRYPrincipleTheory();
            // Design_Patterns.Abstract_Factory.AbstractFactoryTheory ui = new Design_Patterns.Abstract_Factory.AbstractFactoryTheory();
            // Design_Patterns.Factory_Method.FactoryMethodThoery ui = new Design_Patterns.Factory_Method.FactoryMethodThoery();
            Design_Patterns.Singleton.SingletonTheory ui = new Design_Patterns.Singleton.SingletonTheory();
            //BuilderDesignPattern.BuilderTheory ui = new BuilderDesignPattern.BuilderTheory();
            //Threads_Multithreading.Threads_MultithreadingTheory ui = new Threads_Multithreading.Threads_MultithreadingTheory();
            //RegexTheory.RegexTheory ui = new RegexTheory.RegexTheory();
            ui.Execute();

        }
    }
}
